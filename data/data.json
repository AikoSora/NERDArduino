{
  "category": [
    {
      "name": "Операторы",
      "lessons": [
        {
          "id": 1,
          "name": "Функция Setup",
          "description": "Функция setup() вызывается, когда стартует скетч. Используется для инициализации переменных, определения режимов работы выводов, запуска используемых библиотек и т.д. Функция setup запускает только один раз, после каждой подачи питания или сброса платы Arduino.",
          "example_code": "int buttonPin = 3;\n\n\nvoid setup()\n{\n  Serial.begin(9600);\n  pinMode(buttonPin, INPUT);\n}\n\n\n\n\nvoid loop()\n{\n  // ...\n}"
        },
        {
          "id": 2,
          "name": "Функция Loop",
          "description": "После вызова функции setup(), которая инициализирует и устанавливает первоначальные значения, функция loop() делает точь-в-точь то, что означает её название, и крутится в цикле, позволяя вашей программе совершать вычисления и реагировать на них. Используйте её для активного управления платой Arduino.",
          "example_code": "int buttonPin = 3;\n\n\n// setup инициализирует последовательный порт и кнопку\nvoid setup()\n{\n  beginSerial(9600);\n  pinMode(buttonPin, INPUT);\n}\n\n\n// в цикле проверяется состояние кнопки,\n// и на последовательный порт будет отправлено сообщение, если она нажата\nvoid loop()\n{\n  if (digitalRead(buttonPin) == HIGH)\n      serialWrite('H');\n  else\n      serialWrite('L');\n\n\n  delay(1000);\n}"
        }
      ]
    },
    {
      "name": "Управляющие операторы",
      "lessons": [
        {
          "id": 1,
          "name": "Оператор If",
          "description": "if, используется в сочетании с операторами сравнения, проверяет, достигнута ли истинность условия, например, превышает ли входное значение заданное число. Формат оператора if следующий:",
          "example_code": "if (someVariable > 50)\n{\n// выполнять действия\n}"
        },
        {
          "id": 2,
          "name": "Операторы сравнения",
          "description": "x == y (x равно y)\nx != y (x не равно y)\nx < y (x меньше чем y) \nx > y (x больше чем y)\nx <= y (x меньше чем или равно y)\nx >= y (x больше чем или равно y)",
          "example_code": "if (x == y) {}\nif (x != y) {}\nif (x < y) {}\nif (x > y) {}\nif (x <= y) {}\nif (x >= y) {}"
        },
        {
          "id": 3,
          "name": "Оператор if..else if...else",
          "description": "Конструкция if..else предоставляет больший контроль над процессом выполнения кода, чем базовый оператор if, позволяя осуществлять несколько проверок, объединенных вместе. Например, аналоговый вход может быть проверен и выполнено одно действие, если на входе меньше 500, или другой действие, если на входе 500 или больше. Отметим, что конструкция else if может быть использована с или без заключительного else и наоборот. Допускается неограниченное число таких переходов else if.",
          "example_code": "if (pinFiveInput < 500)\n{\n  // выполнять действие A\n}\nelse if (pinFiveInput >= 1000)\n{\n  // выполнять действие B\n}\nelse\n{\n  // выполнять действие  C\n}"
        },
        {
          "id": 4,
          "name": "Оператор Switch",
          "description": "Подобно конструкции if, switch...case управляет процессом выполнения программы, позволяя программисту задавать альтернативный код, который будет выполняться при разных условиях. В частности, оператор switch сравнивает значение переменной со значением, определенном в операторах case. Когда найден оператор case, значение которого равно значению переменной,   выполняется программный код в этом операторе.\n\n\nКлючевое слово break является командой выхода из оператора case и обычно используется в конце каждого case. Без оператора break оператор switchбудет продолжать вычислять  следующие выражения, пока не достигнет break или конец оператора switch.\n\n\nПараметры:\n   * var: переменная, которая вычисляется для сравнения с вариантами в case\n   * label: значение, с которым сравнивается значение переменной",
          "example_code": "switch (var) {\n  case label:\n      // код для выполнения\n      break;\n  case label:\n      // код для выполнения\n      break;\n  default:\n      // выполняется, если не выбрана ни одна альтернатива\n      // default необязателен\n}"
        },
        {
          "id": 5,
          "name": "Оператор For",
          "description": "Конструкция for используется для повторения блока операторов, заключенных в фигурные скобки. Счетчик приращений обычно используется для приращения и завершения цикла. Оператор for подходит для любых повторяющихся действий и часто используется в сочетании с массивами коллекций данных/выводов.\n\n\nЗаголовок цикла for состоит из трех частей:\n\n\nfor (initialization; condition; increment) {операторы выполняющиеся в цикле}\n\n\nИнициализация (Initialization) выполняется самой первой и один раз. Каждый раз в цикле проверяется условие (condition), если оно верно, выполняется блок операторов и приращение (increment), затем условие проверяется вновь. Когда логическое значение условия становится ложным, цикл завершается.",
          "example_code": "// Затемнение светодиода с использованием ШИМ-вывода\n\n\nint PWMpin = 10; // Светодиод последовательно с резистором 470 ом на 10 выводов\n\n\nvoid setup()\n{\n  // настройка не нужна\n}\n\n\n\n\nvoid loop()\n{\n  for (int i=0; i <= 255; i++){\n      analogWrite(PWMpin, i);\n      delay(10);\n  }\n}"
        },
        {
          "id": 6,
          "name": "Циклы while",
          "description": "While будет вычислять в цикле непрерывно и бесконечно до тех пор, пока выражение в круглых скобках, () не станет равно логическому ЛОЖНО. Что-то должно изменять значение проверяемой переменной, иначе выход из цикла while никогда не будет достигнут. Это изменение может происходить как в программном коде, например, при увеличении переменной, так и во внешних условиях, например, при тестировании датчика.",
          "example_code": "while(выражение){\n  // оператор(ы)\n}"
        },
        {
          "id": 7,
          "name": "do ... while",
          "description": "Цикл do работает так же, как и цикл while, за исключением того, что условие проверяется в конце цикла, таким образом, цикл do будет всегда выполняться хотя бы раз.",
          "example_code": "do\n{\n  // последовательность операторов\n} while (проверка условия);"
        },
        {
          "id": 8,
          "name": "break",
          "description": "Break используется для принудительного выхода из циклов do, for или while, не дожидаясь завершения цикла по условию. Он также используется для выхода из оператора switch.",
          "example_code": "for (x = 0; x < 255; x ++)\n{\n  digitalWrite(PWMpin, x);\n  sens = analogRead(sensorPin);\n  if (sens > threshold){      // выходим из цикла если есть сигнал с датчика\n      x = 0;\n      break;\n  }\n  delay(50);\n}"
        },
        {
          "id": 9,
          "name": "continue",
          "description": "Оператор continue пропускает оставшиеся операторы в текущем шаге цикла. Вместо них выполняется проверка условного выражения цикла, которая происходит при каждой следующей итерации.",
          "example_code": "for (x = 0; x < 255; x ++)\n{\n  if (x > 40 && x < 120){      // если истина то прыгаем сразу на следующую итерацию цикла\n      continue;\n  }\n\n\n  digitalWrite(PWMpin, x);\n  delay(50);\n}"
        },
        {
          "id": 10,
          "name": "return",
          "description": "Прекращает вычисления в функции и возвращает значение из прерванной функции в вызывающую, если это нужно.",
          "example_code": "int checkSensor(){\n  if (analogRead(0) > 400) {\n      return 1;\n  } else {\n      return 0;\n  }\n}"
        },
        {
          "id": 11,
          "name": "Оператор goto",
          "description": "Условное «перемещение» выполнения программы к определенной метке-указателю в самой программе, при этом пропускается весь код до самой метки, а исполняется - после нее.",
          "example_code": "label:\n//\n// какой-либо код\n//\ngoto label; // переходим к метке label"
        }
      ]
    },
    {
      "name": "Синтаксис",
      "lessons": [
        {
          "id": 1,
          "name": "; (точка с запятой)",
          "description": "Синтаксис ; (точка с запятой) используется для обозначения конца оператора.",
          "example_code": "int a = 13;"
        },
        {
          "id": 2,
          "name": "{} (фигурные скобки)",
          "description": "Фигурные скобки {} (также называются просто «скобки») – важный элемент языка программирования С. Они используются в нескольких различных конструкциях, приведенных ниже, и это может иногда сбивать с толку начинающих.\n\n\nОткрывающая скобка “{” должна всегда сопровождаться закрывающей скобкой “}”. Это условие, известное как парность (симметричность) фигурных скобок. Arduino IDE (интегрированная среда разработчика) включает подходящий инструмент для проверки парности скобок. Достаточно выделить скобку, или даже поставить курсор сразу же за скобкой, как будет подсвечена её логическая пара.",
          "example_code": "оператор {код}"
        },
        {
          "id": 3,
          "name": "Комментарии",
          "description": "Комментарии – это строки в программе, которые используются для информирования вас самих или других о том, как работает программа. Они игнорируются компилятором и не экспортируются в процессор, таким образом, они не занимают место в памяти микроконтроллера Atmega.\n\n\nКомментарии предназначены только для того, чтобы помочь вам понять (или вспомнить), как работает ваша программа или  объяснить это другим. Есть два способа пометить строку как комментарий:",
          "example_code": "// Однострочный коментарий\n/* Многострочный\nКоментарий */"
        }
      ]
    },
    {
      "name": "Арифметические операторы",
      "lessons": [
        {
          "id": 1,
          "name": "= оператор присваивания",
          "description": "Присваивает переменной слева от оператора значение переменной или выражения, находящееся справа.\n\n\nПеременная слева от оператора присваивания (=) должна быть способна сохранить присваиваемое значение. Если оно выходит за диапазон допустимых значений, то сохраненное значение будет не верно.\n\n\nНеобходимо различать оператор присваивания (=) и оператор сравнения (== двойной знак равенства), который осуществляет проверку на равенство.",
          "example_code": "int sensVal;                 // объявление переменной типа integer\nsensVal = analogRead(0); // присваивание переменной sensVal, значения, считанное с аналогового входа"
        },
        {
          "id": 2,
          "name": "Сложение, вычитание, умножение и деление",
          "description": "Операторы +, -, * и / соответственно, возвращают результат выполнения арифметических действий над двумя операндами. Возвращаемый результат будет зависеть от типа данных операндов, например, 9 / 4 возвратит 2, т.к. операнды 9 и 4 имеют тип int. Также следует следить за тем, чтобы результат не вышел за диапазон допустимых значений для используемого типа данных. Так, например, сложение 1 с переменной типа int и значением 32 767 возвратит -32 768. Если операнды имеют разные типы, то тип с более \"широким\" диапазоном будет использован для вычислений.\n\n\nЕсли один из операндов имеет тип float или double, то арифметика \"с плавающей запятой\" будет использована для вычислений.",
          "example_code": "y = y + 3;\nx = x - 7;\ni = j * 6;\nr = r / 5;"
        },
        {
          "id": 3,
          "name": "% оператор",
          "description": "Возвращает остаток от деления одного целого (int) операнда на другой.",
          "example_code": "result = dividend % divisor"
        }
      ]
    },
    {
      "name": "Логические операторы",
      "lessons": [
        {
          "id": 1,
          "name": "&& (логическое И)",
          "description": "Истина, если оба операнда истина (true).",
          "example_code": "if (digitalRead(2) == HIGH  && digitalRead(3) == HIGH) { // считывает состояние двух портов\n  // ...\n}"
        },
        {
          "id": 2,
          "name": "|| (логическое ИЛИ)",
          "description": "Истина, если хотя бы один операнд истина, например:",
          "example_code": "if (x > 0 || y > 0) {\n  //...\n}"
        },
        {
          "id": 3,
          "name": "! (логическое отрицание)",
          "description": "True, если операнд false, и наоборот, например:",
          "example_code": "if (!x) {\n  //...\n}"
        }
      ]
    },
    {
      "name": "Унарные операторы",
      "lessons": [
        {
          "id": 1,
          "name": "++ (увеличение значения) / -- (уменьшение значения)",
          "description": "Унарные (имеющие один операнд) операторы ++, -- увеличивают, уменьшают значение переменной соответственно.",
          "example_code": "x++;  // увеличивает значение x на единицу и возвращает старое значение x\n++x;  // увеличивает значение x на единицу и возвращает новое значение x\n\n\nx--;   // уменьшает значение x на единицу и возвращает старое значение x\n--x;   // уменьшает значение x на единицу и возвращает новое значение x"
        },
        {
          "id": 2,
          "name": "+= , -= , *= , /=",
          "description": "Короткий способ записи арифметических действий над переменной и одним операндом.",
          "example_code": "x += y;   // эквивалент записи x = x + y;\nx -= y;   // эквивалент записи x = x - y;\nx *= y;   // эквивалент записи x = x * y;\nx /= y;   // эквивалент записи x = x / y;"
        }
      ]
    },
    {
      "name": "Константы",
      "lessons": [
        {
          "id": 1,
          "name": "Логические константы",
          "description": "В языке Ардуино есть две константы для представления логических значений истина и ложь: true и false.\nОбычно говорят, что true — это 1, это корректно, но также корректно то, что для integer любой значение отличное от 0 будет также true в логическом выражение. Т.е -1, -2 и -200 будет также true в логическом выражении.",
          "example_code": "true;\nfalse;"
        },
        {
          "id": 2,
          "name": "Задание значение на входа/выходе, HIGH и LOW",
          "description": "Возможны только два значения для считывания или записи на цифровой порт вход/выхода: HIGH и LOW.\nHIGH может обозначать несколько разное в зависимость от уставки режима порта как INPUT или OUTPUT. Когда порт вход/выхода установлен в режим INPUT с помощью функции pinMode, и считывается функцией digitalRead, микроконтроллер отдаст значение HIGH при напряжение 3В или выше на указанном порту.\nЗначение LOW также разное для режима INPUT и OUTPUT. Когда порт сконфигурирован как INPUT, и считывается функцие digitalRead, микроконтроллер вернет LOW если напряжение на данном порту меньше или равно 2В.",
          "example_code": "digitalRead(2) == HIGH\ndigitalRead(2) == LOW"
        },
        {
          "id": 3,
          "name": "Задание режима порта вход/выхода, INPUT и OUTPUT",
          "description": "Цифровые порты вход/выхода, могут быть установлены в режимы работы как вход или выход: INPUT или OUTPUT. Установка производится функцией pinMode().\nПорты Arduino установленные в режим INPUT находятся в высокоимпедансном состоянии. Это означает то, что порт ввода дает слишком малую нагрузки на схему, в которую он включен. Эквивалентом внутреннему сопротивлению будет резистор 100 МОм подключенный к выводу микросхемы. Таким образом, для перевода порта ввода из одного состояния в другое требуется маленькое значение тока. Это позволяет применять выводы микросхемы для подключения различных датчиков, но не питания.\nПорт установленный в режим выхода — OUTPUT, находится в низкоимпедансном состояние. Он может пропускать через себя довольно большой ток, до 40 mA, достаточный для запитывание внешней цепи, например, светодиода. В этом состоянии порт может быть поврежден как замыкании на землю так и на питание 5В. Тока с порта микроконтроллера не достаточно  для питания моторов и сервоприводов напрямую.",
          "example_code": "pinMode(3, INPUT);\npinMode(4, OUTPUT);"
        },
        {
          "id": 4,
          "name": "Целочисленные константы",
          "description": "Целочисленные константы — это числа используемые напрямую в коде скетча, без определения переменной для их хранения. По умолчанию такие константы трактуются как тип int, но это может быть изменено директивами U и L.",
          "example_code": "digitalRead(2);"
        },
        {
          "id": 5,
          "name": "Константы с плавающей запятой (floating point constants)",
          "description": "Очень похожи на целочисленные константы. Используются в коде программы для более удобного понимания и чтения кода. Значения записываются по зарубежному стандарту только через точку.",
          "example_code": "n = .005;"
        }
      ]
    },
    {
      "name": "Типы данных",
      "lessons": [
        {
          "id": 1,
          "name": "boolean",
          "description": "Логический (булевый) тип данных — boolean. Может принимать одно из двух значений true или false. boolean занимает в памяти один байт.",
          "example_code": "bool is_start = true;\nbool is_running = false;\nbool is_start = 1;\nbool is_running = 0;"
        },
        {
          "id": 2,
          "name": "char",
          "description": "Переменная типа char занимает 1 байт памяти и может хранить один алфавитно-цифровой символ (литеру). При объявление литеры используются одиночные кавычки: 'A' (двойные кавычки используется при объявлении строки символов - тип string: \"ABC\").\n\n\nСимвол хранится в памяти как число, соответствующее коду символа в таблице кодировки символов ASCII.  Т.к. символ хранится как число в памяти над ним возможно производить арифметические действия (например, 'A' + 1 будет 66, т.к. ASCII код для 'A' - 65).\n\n\nТип char знаковый тип, т.е. число (код) хранящийся в памяти может принимать значения от -128 до 127. Если необходим беззнаковая однобайтовая переменная, используйте тип byte.",
          "example_code": "char myChar = 'A';\nchar myChar = 65;"
        },
        {
          "id": 3,
          "name": "byte",
          "description": "Тип данных byte 8-ми битное беззнаковое целое число, в диапазоне 0..255.",
          "example_code": "byte c = B10010;  // \"B\" префикс двоичной системы счисления(B10010 = 18 в десятичной системе счисления)"
        },
        {
          "id": 4,
          "name": "int",
          "description": "Тип данных int (от англ. integer - целое число) один их наиболее часто используемых типов данных для хранения чисел.  int занимает 2 байта памяти, и может хранить числа от -32 768 до 32 767 (от -2^15 до 2^15-1)\n\n\nДля размещения отрицательных значений int использует, так называемый, дополнительный код представления числа. Старший бит указывает на отрицательный знак числа, остальные биты инвертируются с добавлением 1.\n\n\nArduino компилятор сам заботиться о размещение в памяти и представление отрицательных чисел, поэтому арифметические действия над целыми числами производятся как обычно.",
          "example_code": "int ledPin = 13;"
        },
        {
          "id": 5,
          "name": "unsigned int",
          "description": "Тип данных unsigned int - беззнаковое целое число, также как и тип int (знаковое) занимает в памяти 2 байта. Но в отличие от int, тип unsigned int может хранить только положительные целые числа в диапазоне от 0 до 65535 (2^16)-1).",
          "example_code": "unsigned int ledPin = 13;"
        },
        {
          "id": 6,
          "name": "word",
          "description": "Тип данных word хранит 16-битное, не содержащее знака, число от 0 до 65535. Тоже самое, что unsigned int — (беззнаковое целое число).",
          "example_code": "word w = 10000;"
        },
        {
          "id": 7,
          "name": "long",
          "description": "Тип данных long используется для хранения целых чисел в расширенном диапазоне от -2,147,483,648 до 2,147,483,647. long занимает 4 байта в памяти.",
          "example_code": "long speedOfLight = 186000L;  // См. значение постфикса 'L' в теме Целочислесленные константы"
        },
        {
          "id": 8,
          "name": "unsigned long",
          "description": "Unsigned long используется для хранения положительных целых чисел в диапазоне от 0 до 4,294,967,295 (2^32 - 1) и занимает 32 бита (4 байта) в памяти.",
          "example_code": "unsigned long number = 228;"
        },
        {
          "id": 9,
          "name": "float",
          "description": "Тип данных float служит для хранения чисел с плавающей запятой. Этот тип часто используется для операций с данными, считываемыми с аналоговых входов. Диапазон значений — от -3.4028235E+38 до 3.4028235E+38. Переменная типа float занимает 32 бита (4 байта) в памяти.\nТип float имеет точность 6-7 знаков, имеются ввиду все знаки, а не только мантисса. Обычно для увеличения точности используют другой тип - double, но на платформе Arduino, double и float имеют  одинаковую точность.",
          "example_code": "float sensorCalbrate = 1.117;"
        },
        {
          "id": 10,
          "name": "double",
          "description": "Тип данных double, в отличие от большинства языков программирования, имеет ту же точность, что и тип float и занимает также 4 байта памяти.\nТип double поддерживается в Arduino для совместимости кода с другими платформами.",
          "example_code": "double aboba = 1.117;"
        },
        {
          "id": 11,
          "name": "string - текстовые строки",
          "description": "Текстовые строки в Ардуино объявляются как массив (array) типа char (символов - литер), оканчивающийся символом \"конца строки\".",
          "example_code": "char Str1[15];\nchar Str2[8] = {'a', 'r', 'd', 'u', 'i', 'n', 'o'};\nchar Str3[8] = {'a', 'r', 'd', 'u', 'i', 'n', 'o', '\\0'};\nchar Str4[ ] = \"arduino\";\nchar Str5[8] = \"arduino\";\nchar Str6[15] = \"arduino\";"
        },
        {
          "id": 12,
          "name": "String",
          "description": "String класс появился в версии Arduino 0019. Этот класс позволяет хранить и манипулировать текстовыми строками, по сравнению с string (массивом символов) класс String предоставляет удобные функции для работы со строками, такие как поиск вхождения в строку, объединение строк и др. Класс String занимает несколько больше места в памяти, чем массив символов string.",
          "example_code": "..."
        },
        {
          "id": 13,
          "name": "Массивы",
          "description": "Массивы (arrays) — именованный набор однотипных переменных, с доступом к отдельным элементам по их индексу.",
          "example_code": "int myInts[6];\nint myPins[] = {2, 4, 8, 3, 6};\nint mySensVals[6] = {2, 4, -8, 3, 2};\nchar message[6] = \"hello\";\n//Доступ к элементам массива\nint myArray[10]={9,3,2,4,3,2,7,8,9,11};\n// myArray[0]    первый элемент, содержит 9\n// myArray[9]    последний элемент, содержит 11\n// myArray[10]   это неверно возможно возвращение произвольного значения из области памяти не относящийся к массиву"
        },
        {
          "id": 14,
          "name": "void",
          "description": "Ключевое слово void используется при объявлении функций, если функция не возвращает никакого значение при ее вызове (в некоторых языках программирования такие функции называют процедурами).",
          "example_code": "// в функциях \"setup\" и \"loop\" производятся некоторые действия,\n// но ничего не возвращается во внешнюю программу\n\n\nvoid setup() { //... }\n\n\nvoid loop() { //... }"
        }
      ]
    },
    {
      "name": "Преобразование типов данных",
      "lessons": [
        {
          "id": 1,
          "name": "char()",
          "description": "char() приводит значение к типу char.",
          "example_code": "char(x);"
        },
        {
          "id": 2,
          "name": "byte()",
          "description": "byte() приводит значение к типу byte.",
          "example_code": "byte(x);"
        },
        {
          "id": 3,
          "name": "int()",
          "description": "int() приводит значение к типу int.",
          "example_code": "int(x);"
        },
        {
          "id": 4,
          "name": "long()",
          "description": "long() приводит значение к типу long.",
          "example_code": "long(x);"
        },
        {
          "id": 5,
          "name": "float()",
          "description": "float() приводит значение к типу float.",
          "example_code": "float(x);"
        }
      ]
    },
    {
      "name": "Область видимости переменных и квалификаторы",
      "lessons": [
        {
          "id": 1,
          "name": "Область видимости переменных",
          "description": "Переменные в языке программирования С, используемом Arduino, обладают свойством, которое называется область видимости, в отличие от языков, подобных BASIC, где каждая переменная является глобальной.\n\n\nГлобальная переменная доступна для любой функции в программе. Локальные переменные видны только в той функции, в которой они объявлены. В среде Arduino любая переменная, объявленная вне функции (например, setup(), loop() и т.д.), является глобальной переменной.\n\n\nКогда программа начинает разрастаться и усложняться, использование локальных переменных – удобный способ, гарантирующий, что только одна функция будет иметь доступ к своим собственным переменным. Тем самым предотвращаются ошибки программирования, когда одна функция непреднамеренно изменяет значения переменных, используемых другой функцией.\n\n\nТакже иногда бывает удобно объявить и инициализировать переменную внутри цикла. При этом создается переменная, доступная только внутри скобок цикла for.",
          "example_code": "int gPWMval;  // глобальная переменная, видима в любой функции скетча\n\n\nvoid setup() { //... }\n\n\nvoid loop()\n{\n  int i;    // \"i\" видима только внутри \"loop\"\n  float f;  // \"f\" видима только внутри \"loop\"\n  // ...\n\n\n  for (int j = 0; j <100; j++){\n      // переменная j доступна только внутри этого цикла\n  }\n}"
        },
        {
          "id": 2,
          "name": "Квалификатор static",
          "description": "Ключевое слово static используется для создания переменной, которая видна только одной функции. Однако в отличие от локальных переменных, которые создаются и уничтожаются при каждом вызове функции, статические переменные остаются после вызова функции, сохраняя свои значения между её вызовами.",
          "example_code": "int randomWalk(int moveSize){\n  static int  place;     // переменная сохраняет значение между вызовами функции\n  // другие функции не могут изменять значение этой переменной\n\n\n  place = place + (random(-moveSize, moveSize + 1));\n\n\n  if (place < randomWalkLowRange){    // проверяем выхождение за границы\n      place = place + (randomWalkLowRange - place);     // если \"выскочили\" то делаем разворот\n      // этот пример взят с arduino.cc, вообще? если раскрыть скобки,\n      // то получим просто place = randomWalkLowRange;\n  }\n  else if(place > randomWalkHighRange){\n      place = place - (place - randomWalkHighRange);     // разворот\n  }\n\n\n  return place;\n}"
        },
        {
          "id": 3,
          "name": "Квалификатор volatile",
          "description": "Квалификатор volatile, используется перед типом переменной, чтобы изменить способ интерпретации и доступа к переменной компилятором и в дальнейшем программой.\n\n\nОбъявление переменной с квалификаторм volatile – это указание для компилятора. Компилятор – это программа, которая переводит текст вашей программы на С/С++ в машинный код, то есть в реальные команды для чипа Atmega в Arduino.\n\n\nОн указывает компилятору загрузить переменную из ОЗУ, и не из запоминающего регистра – временной ячейки памяти, в которой хранятся переменные программы и производятся операции с ними. При определенных условиях значения переменных, хранящихся в регистрах, могут оказаться неточными.\n\n\nПеременная должна быть объявлена volatile, когда её значение может быть изменено чем-либо за пределами того участка программы, где она объявлена, например, параллельно выполняющимся процессом. В Arduino единственным местом, где это может проявиться, является участок программы, ассоциированным с прерываниями, вызванный программой обработки прерываний.",
          "example_code": "// переключаем светодиод, когда вызывается прерывание, изменением состояния входного пина\nint pin = 13;\nvolatile int state = LOW;\n\n\nvoid setup()\n{\n  pinMode(pin, OUTPUT);\n  attachInterrupt(0, blink, CHANGE);\n}\n\n\nvoid loop()\n{\n  digitalWrite(pin, state);\n}\n\n\nvoid blink()\n{\n  state = !state;\n}"
        },
        {
          "id": 4,
          "name": "Квалификатор const",
          "description": "Ключевое слово const обозначает константы. Это квалификатор переменной, изменяющий её свойства, делающий её доступной только для чтения. Это означает, что переменная может использоваться так же как и любая ругая переменная этого типа, но её значение не может быть изменено. Если вы попытаетесь присвоить переменной типа константа значение, вы получите ошибку компилятора.\n\n\nКонстанты, объявленные с помощью ключевого слова const, подчиняются тем же правилам определения их области видимости, что и другие переменные. Это, и подвохи в использовании директивы #define, делают ключевое слово const превосходным способом задания констант и более предпочтительным, чем использование #define.\nМожно использовать как const, так и #define для создания численных и строковых констант. В массивах можно использовать только константы, объявленные с квалификаторм const. В общем случае лучше использовать const, а не #define для создания констант.",
          "example_code": "const float pi = 3.14;\nfloat x;\n\n\n// ....\n\n\nx = pi * 2;    // константы можно использовать в вычислениях\npi = 7;        // ошибка - нельзя присваивать значение константе"
        }
      ]
    },
    {
      "name": "Цифровой ввод/вывод",
      "lessons": [
        {
          "id": 1,
          "name": "Функция pinMode",
          "description": "Устанавливает режим работы заданного вход/выхода(pin) как входа или как выхода.",
          "example_code": "pinMode(pin, mode);"
        },
        {
          "id": 2,
          "name": "Функция digitalWrite()",
          "description": "Подает HIGH или LOW значение на цифровой вход/выход (pin).\n\n\nЕсли вход/выход (pin) был установлен в режим выход (OUTPUT) функцией pinMode(), то для значение HIGH напряжение на соответствующем вход/выходе (pin) будет 5В (3.3В для 3.3V плат), и 0В(земля) для LOW.\n\n\nЕсли вход/выход (pin) был установлен в режим вход (INPUT), то функция digitalWrite со значением HIGH будет активировать внутренний 20K нагрузочный резистор. Подача LOW в свою очередь отключает этот резистор.  Нагрузочного резистра достаточно чтобы светодиод, подключенный к входу, светил тускло. Если вдруг светодиод работает, но очень тускло, возможно необходимо установить режим выход (OUTPUT) функцией pinMode().\n\n\nЗамечание. Вход/выход 13 сложнее использовать как цифровой вход, т.к. он имеет встроенный в плату резистор и светодиод. Если вы активируете еще внутренний нагрузочный резистор 20K, то напряжение на этом входе будет около 1.7В, вместо ожидаемых 5В, т.к. светодиод и добавочный резистор снижает напряжение, т.е. Вы всегда будете получать LOW. Если же Вам все же необходимо использовать 13ый вход/выход, то  используйте внешний нагрузочный резистор.",
          "example_code": "digitalWrite(pin, value);"
        },
        {
          "id": 3,
          "name": "Функция digitalRead()",
          "description": "Функция считывает значение с заданного входа - HIGH или LOW.",
          "example_code": "digitalRead(pin);"
        }
      ]
    },
    {
      "name": "Аналоговый ввод/вывод",
      "lessons": [
        {
          "id": 1,
          "name": "Функция analogRead()",
          "description": "Функция считывает значение с указанного аналогового входа. Большинство плат Arduino имеют 6 каналов (8 каналов у платы Mini  и Nano, 16 у Mega) c 10-битным аналого-цифровым преобразователем (АЦП). Напряжение  поданное на аналоговый вход, обычно от 0 до 5 вольт будет преобразовано в значение от 0 до 1023, это 1024 шага с разрешением 0.0049 Вольт. Разброс напряжение и шаг может быть изменен функцией analogReference().\nСчитывание значение с аналогового входа занимает примерно 100 микросекунд (0.0001 сек), т.е. максимальная частота считывания приблизительно 10,000 раз в секунду.",
          "example_code": "analogRead(pin);"
        },
        {
          "id": 2,
          "name": "Функция analogReference()",
          "description": "Функция определяет опорное напряжение относительно которого происходят аналоговые измерения. Функция analogRead() возвращает значение с разрешением 10 бит пропорционально входному напряжению на аналоговом входе, и в зависимости от опорного напряжения.\n\n\nВозможные настройки:\n\n\n   * DEFAULT: стандартное опорное напряжение 5 В (на платформах с напряжением питания 5 В) или 3.3 В (на платформах с напряжением питания 3.3 В)\n   * INTERNAL: встроенное опорное напряжение 1.1 В на микроконтроллерах ATmega168 и ATmega328, и 2.56 В на ATmega8.\n   * INTERNAL1V1: встроенное опорное напряжение 1.1 В (Arduino Mega)\n   * INTERNAL2V56: встроенное опорное напряжение 2.56 (Arduino Mega)\n   * EXTERNAL: внешний источник опорного напряжения, подключенный к выводу AREF",
          "example_code": "analogReference(type);"
        },
        {
          "id": 3,
          "name": "Функция analogWrite()",
          "description": "Выдает аналоговую величину (ШИМ волну) на порт вход/выхода. Функция может быть полезна для управления яркостью подключенного светодиода или скоростью электродвигателя. После вызова analogWrite() на выходе будет генерироваться постоянная прямоугольная волна с заданной шириной импульса до следующего вызова analogWrite (или вызова digitalWrite или digitalRead на том же порту вход/выхода). Частота ШИМ сигнала приблизительно 490 Hz.\n\n\nНа большинстве плат Arduino (на базе микроконтроллера ATmega168 или ATmega328) ШИМ поддерживают порты 3, 5, 6, 9, 10 и 11, на плате Arduino Mega порты с 2 по 13. На более ранних версиях плат Arduino analogWrite() работал только на портах 9, 10 и 11.\nДля вызова analogWrite() нет необходимости устанавливать тип вход/выхода функцией pinMode().\nФункция analogWrite никак не связана с аналоговыми входами и с функцией analogRead.",
          "example_code": "analogWrite(pin, value);"
        }
      ]
    },
    {
      "name": "Дополнительные фунции ввода/вывода",
      "lessons": [
        {
          "id": 1,
          "name": "tone()",
          "description": "Генерирует на порту вход/выхода сигнал — прямоугольную \"волну\", заданной частоты и с 50% рабочим циклом. Длительность может быть задана параметром, в противном случае сигнал генерируется пока не будет вызвана функция noTone(). К порту вход/выхода может быть подключен к  пьезо или другой динамик для воспроизведения сигнала.\nВоспроизводиться одновременно может только один сигнал. Если сигнал уже воспроизводится на одном порту, то вызов Tone() с номером другого порта в качестве параметра ни к чему не приведет, если же Tone() будет вызвана с тем же номером порта, то будет установлена новая частота сигнала.\nИспользование функции Tone() помешает использовать ШИМ на портах вход/выхода 3 и 11 (кроме платы Arduino Mega).",
          "example_code": "tone(pin, frequency);\ntone(pin, frequency, duration);"
        },
        {
          "id": 2,
          "name": "noTone()",
          "description": "Останавливает сигнал, генерируемый на порту вход/выхода вызывом функции Tone(). Если сигнал не генерировался, то вызов noTone() ни к чему не приводит.\nЗамечание: если необходимы сигналы на разных порты, то следует сначала остановить один сигнал функцией noTone(), а лишь затем создавать новый сигнал на другом порту функцией Tone().",
          "example_code": "noTone(pin);"
        },
        {
          "id": 3,
          "name": "shiftOut()",
          "description": "Выводит байт информации на порт вход/выхода последовательно (побитно). Вывод может осуществляться как с первого (левого), так и с последнего (правого) бита. Каждый бит последовательно подается на заданный порт, после чего подается сигнал на синхронизирующий порт вход/выход, информируя о доступности к считыванию бита.\nТакой способ передачи данных называют последовательный протокол с синхронизацией. Он часто используется для взаимодействия микроконтроллеров с датчиками и сенсорами, а также другими микроконтроллерами. Последовательная передача с синхронизацией позволяет устройствам связываться на максимальной скорости.",
          "example_code": "shiftOut(dataPin, clockPin, bitOrder, value);"
        },
        {
          "id": 4,
          "name": "pulseIn()",
          "description": "Считывает длину сигнала на заданном порту (HIGH или LOW). Например, если задано считывание HIGH функцией pulseIn(), функция ожидает пока на заданном порту не появиться HIGH. Когда HIGH получен, включается таймер, который будет остановлен когда на порту вход/выхода будет LOW. Функция pulseIn() возвращает длину сигнала в микросекундах. Функция возвращает 0, если в течение заданного времени (таймаута) не был зафиксирован сигнал на порту.\nВозможны некоторые погрешности в измерение длинных сигналов. Функция может измерять сигналы длиной от 10 микросекунд до 3 минут.",
          "example_code": "pulseIn(pin, value);\npulseIn(pin, value, timeout);"
        }
      ]
    },
    {
      "name": "Работа со временем",
      "lessons": [
        {
          "id": 1,
          "name": "millis()",
          "description": "Возвращает количество миллисекунд с момента начала выполнения текущей программы на плате Arduino. Это количество сбрасывается на ноль, в следствие переполнения значения, приблизительно через 50 дней.",
          "example_code": "unsigned long time;\n\n\nvoid setup(){\n  Serial.begin(9600);\n}\n\n\nvoid loop(){\n  Serial.print(\"Time: \");\n  time = millis();\n  //выводит количество миллисекунд с момента начала выполнения программы\n  Serial.println(time);\n  // ждет секунду, перед следующей итерацией цикла.\n  delay(1000);\n}"
        },
        {
          "id": 2,
          "name": "micros()",
          "description": "Возвращает количество микросекунд с момента начала выполнения текущей программы на плате Arduino. Значение переполняется и сбрасывается на ноль, приблизительно через 70 минут. На 16MHz платах Ардуино (Duemilanove и Nano) функция micros() имеет разрешение 4 микросекунды (возвращаемое значение всегда кратно 4). На 8MHz платах (Arduino Lilypad) разрешение функции 8 микросекунд.\n(в одной секунде 1 000 миллисекунд и 1 000 000 микросекунд)",
          "example_code": "unsigned long time;\ntime = micros();\nSerial.println(time);"
        },
        {
          "id": 3,
          "name": "delay()",
          "description": "Останавливает выполнение программы на заданное в параметре количество миллисекунд (1000 миллисекунд в 1 секунде).",
          "example_code": "delay(ms);"
        },
        {
          "id": 4,
          "name": "delayMicroseconds()",
          "description": "Останавливает выполнение программы на заданное в параметре количество микросекунд (1 000 000 микросекунд в 1 секунде).\n\n\nВ данной версии Ардуино максимальная пауза воспроизводимая корректно — 16383. Возможно это будет изменено в следующих версиях Arduino. Для остановки выполнения программы более чем на несколько тысяч микросекунд рекомендуется использовать функцию delay().",
          "example_code": "delayMicroseconds(us)"
        }
      ]
    },
    {
      "name": "Математические функции",
      "lessons": [
        {
          "id": 1,
          "name": "min(x,y)",
          "description": "Возвращает наименьшее из двух значений.",
          "example_code": "sensVal = min(sensVal, 100); // проверяем если sensVal больше 100, то senseVal будет присвоено 100"
        },
        {
          "id": 2,
          "name": "max(x, y)",
          "description": "Возвращает большее из двух значений.",
          "example_code": "sensVal = max(sensVal, 20); // проверяем если sensVal меньше 20, то senseVal будет присвоено 20"
        },
        {
          "id": 3,
          "name": "abs()",
          "description": "Возвращает модуль числа.",
          "example_code": "abs(a, 0);"
        },
        {
          "id": 4,
          "name": "constrain(x, a, b)",
          "description": "Функция проверяет и если надо задает новое значение, так чтобы оно была в области допустимых значений, заданной параметрами.",
          "example_code": "sensVal = constrain(sensVal, 10, 150); // ограничиваем значения sensVal диапазоном от 10 до 150"
        },
        {
          "id": 5,
          "name": "map(value, fromLow, fromHigh, toLow, toHigh)",
          "description": "Функция пропорционально переносит значение (value) из текущего диапазона значений (fromLow .. fromHigh) в новый диапазон (toLow .. toHigh), заданный параметрами.\nФункция map() не ограничивает значение рамками диапазона, как это делает функция constrain(). Contrain() может быть использован до или после вызова map(), если необходимо ограничить допустимые значения заданным диапазоном.\nОбратите внимание, что \"нижняя граница\" может быть как меньше, так и больше \"верхней границы\". Это может быть использовано для того чтобы \"перевернуть\" диапазон:\n\n\ny = map(x, 1, 50, 50, 1);\n\n\nВозможно использование отрицательных значений:\n\n\ny = map(x, 1, 50, 50, -100);\n\n\nФункция map() оперирует целыми числами. При пропорциональном переносе дробная часть не округляется по правилами, а просто отбрасывается.",
          "example_code": "/* Переносим значение с аналогового входа (возможные значения от 0 до 1023) в 8 бит (0..255) */\nvoid setup() {}\n\n\nvoid loop()\n{\n  int val = analogRead(0);\n  val = map(val, 0, 1023, 0, 255);\n  analogWrite(9, val);\n}"
        },
        {
          "id": 6,
          "name": "pow(base, exponent)",
          "description": "Вычисляет значение возведенное в заданную степень. pow() может возводить в дробную степень.",
          "example_code": "pow(x, y);"
        },
        {
          "id": 7,
          "name": "sq()",
          "description": "Функция возвращает квадрат числа, заданного параметром.",
          "example_code": "sq(x);"
        },
        {
          "id": 8,
          "name": "sqrt()",
          "description": "Функция вычисляет квадтратный корень числа, заданного параметром.",
          "example_code": "sqrt(x);"
        }
      ]
    },
    {
      "name": "Тригонометрические функции",
      "lessons": [
        {
          "id": 1,
          "name": "sin(rad)",
          "description": "Возвращает синус угла, заданного в радианах. Результат функции всегда в диапазоне -1..1.",
          "example_code": "sin(rad);"
        },
        {
          "id": 2,
          "name": "cos(rad)",
          "description": "Возвращает косинус угла, заданного в радианах в параметре. Результат функции всегда находится в диапазоне -1..1.",
          "example_code": "cos(rad);"
        },
        {
          "id": 3,
          "name": "tan(rad)",
          "description": "Возвращает тангенс угла, заданного в радианах в передаваемом параметре. Результат функции в диапазоне от минус бесконечность до плюс бесконечность.",
          "example_code": "tan(rad);"
        }
      ]
    },
    {
      "name": "Генераторы случайных значений",
      "lessons": [
        {
          "id": 1,
          "name": "randomSeed(seed)",
          "description": "Функция RandomSeed() инициализирует генератор псевдослучайных чисел. Генерируемая последовательность случайных чисел очень длинная, и всегда одна и та же. Точка в этой последовательности, с которой начинается генерация чисел, зависит от параметра seed.\nЕсли при каждом запуске программы необходимо получать разные последовательности значений, генерируемых функцией random(), то необходимо инициализировать генератор псевдослучайных чисел со случайным параметром. Например, можно использовать значение, отдаваемое функцией analogRead() c неподключенного порта вход/выхода.\nВ некоторых случаях необходимо получать одинаковую последовательность при каждом запуске программы на Arduino. В этом случае инициализировать генератор псевдослучайных чисел следует вызовом функции randomSeed() с фиксированным параметром.",
          "example_code": "long randNumber;\n\n\nvoid setup(){\n  Serial.begin(9600);\n  randomSeed(analogRead(0));\n}\n\n\nvoid loop(){\n  randNumber = random(300);\n  Serial.println(randNumber);\n  delay(50);\n}"
        },
        {
          "id": 2,
          "name": "random()",
          "description": "Функция random() возвращает псевдослучайное число.",
          "example_code": "random(max);\nrandom(min, max);"
        }
      ]
    },
    {
      "name": "Внешние прерывания",
      "lessons": [
        {
          "id": 1,
          "name": "attachInterrupt(interrupt, function, mode)",
          "description": "Задает функцию обработки внешнего прерывания, то есть функция, которая будет вызвана по внешнему прерыванию. Если до это была задана другая функция, то назначается новая. Большинство контроллеров Arduino умеют обрабатывать до двух внешних прерываний, пронумерованных так: 0 (на цифровом порту 2) и 1 (на цифровом порту 3). Arduino Mega обрабатывает дополнительно еще четыра прерывания: 2 (порт 21), 3 (порт 20), 4 (порт 19) и 5 (порт 18).",
          "example_code": "attachInterrupt(0, function, CHANGE);"
        },
        {
          "id": 2,
          "name": "detachInterrupt(interrupt)",
          "description": "Выключает обработку внешнего прерывания.",
          "example_code": "..."
        }
      ]
    },
    {
      "name": "Функции передачи данных",
      "lessons": [
        {
          "id": 1,
          "name": "Serial",
          "description": "Набор функций Serial служит для связи устройства Ардуино с компьютером или другими устройствами, поддерживающими последовательный интерфейс обмена данными. Все платы Arduino имеют хотя бы один последовательный порт (UART, иногда называют USART). Для обмена данными Serial используют цифровые порты ввод/вывода 0 (RX) и 1 (TX), а также USB порт. Важно учитывать, что если вы используете функции Serial, то нельзя одновременно с этим использовать порты 0 и 1 для других целей.\n\n\nСреда разработки Arduino имеет встроенный монитор последовательного интерфейса (Serial monitor). Для начала обмена данными необходимо запустить монитор нажатием кнопки Serial monitor и выставить ту же скорость связи (baud rate), с которой вызвана функция begin().\n\n\nПлата Arduino Mega имеет три дополнительных последовательных порта: Serial1 на портах 19 (RX) и 18 (TX), Serial2 на портах на портах 17 (RX) и 16 (TX), Serial3 на портах на портах 15 (RX) и 14 (TX). Чтобы использовать эти порты для связи с компьютером понадобится дополнительные адаптеры USB-to-serial, т.к. они не подключены к встроенному адаптеру платы Mega. Для связи с внешним устройством через последовательный интерфейс соедините TX порт вашего устройства с RX портом внешнего устройства и RX порт вашего устройства с портом TX внешнего и соедините \"землю\" на устройствах. (Важно! Не подключайте эти порты напрямую к RS232 порту, это может повредить плату).",
          "example_code": "//Functions\nbegin();\nend();\navailable();\nread();\nflush();\nprint();\nprintln();\nwrite();\npeek();"
        }
      ]
    }
  ]
}
